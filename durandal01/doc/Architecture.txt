Routes
------

Routes are used to go to/from major sections of the GUI, and could be
considered (and are sometimes refered to) as pages.  Some routes are
authenticated, some routes are not.  The landing page and the signin
page are not authenticated.  There is a video play page that non-viblio
users can come to when they've been shared a video.

Routes can be visible or not to a view that manages the common page
header.  In this GUI, "home" (probably the channels page?) and "upload"
appear to be the only visible routes.  

In App/main.js the routes are established and marked as visible (or not)
and authenticated (or not).  See App/main.js for examples.

In App/viewmodels/shell.js we set up the routers "guardRoute" method
with our logic for determining whether the user can proceed to the
route they are trying to get to.  We "remember" the attempted route
in case there is an authentication failure.  An authentication
failure will redirect to the signin page.  After a successful signin,
the user will be taken to the last attempted route, or the "home"
page if there was no last failed attempt.

In some cases (like the transition to the player page to play a 
video), you need to pass parameters to the route that the target
page viewmodel can get to.  Durandal 1.x does not support route
params natively.  But you can:

    router.navigate( '#/target?foo=bar' );

and in the target view model:

    define( ['purl' ], function() {
      var query_params_hash = $.url(window.location.href.replace('/#','')).param();
      console.log( query_params_hash.foo );

There is a virtual-to-phyical route name mapper in the "config" library
(see below).  The idea is/was that during development, we may change what
pages (routes) are navigated to.  Using this technique:

    router.navigate( '#/' + config.routes.landing );

This way we can change where "landing" maps to by changing it in one place
(config.js) instead of changing multiple places in the application code.

Application-wide Config
-----------------------

App/lib/config.js can be required to get at application-wide configuration
parameters and methods.  Anything that needs to be global can go here.  
Example usage:

    define( ['lib/config' ], function( config ) {
      console.log( 'The Facebook APPID is ' + config.facebook_appid() );

Dialogs
-------

Let's centralize application dialogs in one place so we can create
a unified and consistent use model and visual presentation.  There
is App/plugins/dialog.js, which presently contains showMessage() and
showModel() which just call the standard Durandal app methods.  We
can change this later.  The GUI should always use dialogs from this
model.

    define( ['plugins/dialog'], function( dialogs ) {
      dialogs.showMessage( 'You blew it!' );

Custom Knockout Bindings
------------------------

We've created App/lib/custom_bindings.js, which is already included
in App/main.js, so any bindings defined in custom_bindings will be
available to views.  Put your custom bindings there.

Viblio APIs
-----------

Access to the viblio server web apis is handled through App/lib/viblio.js.
You should call viblio apis using that library instead of using jQuery
or Durandal ajax calls.  The viblio library has been written to try to
gracefully handle authentication failures and sheild the application from
having to deal with errors.  The main call you will use looks like this:

    define( ['lib/viblio', function( viblio ) {
      return {
        viewAttached: function( view ) {
	  return viblio.api( '/services/user/media',
	                     { mid: media_uuid } ).then( function( res ) {
			       console.log( JSON.stringify( res.media );
                             });
        }
      };
    });

viblio.api() is "promise"-based.  Any authentication problems (like
session expires) will be handled by the library so you should not have
to deal with them.  If { error: true } is returned from the server,
the library will show a dialog on the GUI.  Your application code's
promise gets resolved only when there is good data to parse.  If
this is too restrictive for your purposes, then you may use jQuery
or Durandal ajax calls natively, but then you must handle the error
cases.

Error/Debug/Info Logging
------------------------

The viblio library contains log(), debug() and log_error() methods.  You
should use these instead of system.log() or console.log().  Presently
they all just call system.log() internally, but at some point will
be replaced with something like log4javascript, so we can capture
errors on the server if we wish.

    viblio.log( 'Return value', res );
    viblio.log_error( 'This should not have happened' );

Vendor Javascript Libraries
---------------------------

I've violated Durandal convension a little bit here.  If a 3rd
party javascript library is simply a single .js file, go ahead
and put it in ./Scripts (see purl.js), but if it has a structure
and includes js, css, images, etc, then I've been putting the
3rd party package into ./Vendor.  For example, flowplayer comes
with a bunch of assests.  Rather then break it up into peices,
I simply store the whole thing under ./Vendor.  Easier to
manage that way.

Deployment
----------

I love the whole Mimosa idea and flow in Durandal, but unfortunatly
its broken in Durandal 1.x and not yet ready in 2.x.  I had a lot
of little problems with it, so I gave up.  We'll have to manage 
deployment ourselves at some point, or migrate to Durandal 2.0
when its ready.  For now, please look at index.html.  When you
add a 3rd party vendor lib, add it at the bottom of index.html
if you need to (or App/main.js if possible, if the library
supports AMD).  If your view/model requires a .css file, add it
in the header in index.html.

At some point we'll emulate Mimosa's deployment features, or
use some other tool.  We need to combine the .css files into
one.  We need to minify and combine the vendor libraries into
one.  We should combine the view.html files into the javascript
library as "text!" models.  The index.html will then look
a bit different.

